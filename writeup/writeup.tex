%%% use twocolumn and 10pt options with the asme2ej format
\documentclass[twocolumn,10pt]{asme2ej}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{bm}
\usepackage{epsfig} %% for loading postscript figures
\usepackage{graphicx}
\usepackage{algorithm}
\usepackage{algorithmicx, float}
\usepackage{algpseudocode}

\title{A Tensor Algebraic Approach to St. Venant-Kirchhoff Deformations}

\author{Gillian P. Reyes
}
\DeclareMathOperator{\vect}{vec}
\DeclareMathOperator{\tr}{tr}
\begin{document}

\maketitle

% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{abstract}
{\it In Real-Time Subspace Integration for Reduced-Order St. Venant-Kirchhoff Deformable Models by Barbič and James \cite{barbic}, a faster, more efficient method for simulating deformable solids was proposed. These speedups were achieved through two modifications - reducing the dimensions of the Euler-Lagrange equation of motion with a reduced deformation basis, and precomputing coefficients for a polynomial approach to solving the internal force and the tangent stiffness matrix. While the results of this paper were incredible, they are hard to reproduce, as it is hard to decipher exactly what was done to reach the end result. The goal of this paper is to document each step taken to recreate the results of their 2005 paper, so that others may understand and replicate their work. This paper also proposes a new, tensor algebraic approach to solving the internal force and stiffness matrix polynomials. In order to do this, a new tensor n-mode product rule was defined
}
\end{abstract}

% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}

The goal of this paper is to document each step taken in recreating Barbič and James's research from their 2005
paper \cite{barbic}. In this research, they utilize past work on real-time deformable objects and model reduction in solid mechanics to speed up computations and allow for large deformations. Finite Element Method is used to discretize partial differential equations of solid continuum mechanics, allowing motion to be described through the Euler-Lagrange equation,

\begin{equation}
\bm{M\ddot u} + \bm{D}(\bm{u}, \bm{\dot u}) + \bm{R}(\bm{u}) = \bm{f}
\label{eq_motion}
\end{equation}

where $\bm{M} \in \mathbb{R}^{2n \times 2n }$ is the mass matrix, $\bm{D}$ is the damping force, $\bm{R}$ is internal force, and $\bm{f}$ is external force. $\bm{u} \in \mathbb{R}^{2n}$ is the displacement vector. This equation is then further reduced by introducing a time-independent matrix, $\bm{U} \in \mathbb{R}^{2n \times r}$, specifying a basis of some r-dimensional linear subspace. After this reduction, the equation and each of its terms can be solved using:

\begin{equation}
\bm{\tilde{M}\ddot q} + \bm{\tilde{D}}(\bm{q}, \bm{\dot q}) + \bm{\tilde{R}}(\bm{q}) = \bm{\tilde{f}}
\label{eq_rmotion}
\end{equation}

where $\bm{q}, \bm{\tilde{D}}(q, \dot q), \bm{\tilde{R}}(q), \bm{\tilde{f}} \in \mathbb{R}^{r}$, $\tilde{M} \in \mathbb{R}^{r \times r}$, and each
can be found through the equations:

\begin{equation}
\bm{u} = \bm{Uq}
\label{eq_basisreduction}
\end{equation}
\begin{equation}
\bm{\tilde{M}} = \bm{U^{T}MU}
\label{eq_rmass}
\end{equation}
\begin{equation}
\bm{\tilde{D}}(\bm{q}, \bm{\dot q}) = \bm{U^{T}D}(\bm{Uq}, \bm{U \dot q})
\label{eq_rdamp}
\end{equation}
\begin{equation}
\bm{\tilde{R}}(\bm{q}) = \bm{U^{T}D}(\bm{Uq})
\label{eq_rinternal}
\end{equation}
\begin{equation}
\bm{\tilde{f}} = \bm{U^{T}f}
\label{eq_rexternal}
\end{equation}
\begin{equation}
\bm{\tilde{K}} = \bm{U^{T}K}(\bm{Uq})\bm{U}
\label{eq_rstiffness}
\end{equation}

Using these equations to reduce the problem speeds up the computation of motion to a degree, but everything can be
sped up further if you treat the calculation of $\bm{R}$ as cubic polynomial and $\bm{K}$ as a quadratic polynomial. Then,
you can precompute constant coefficients to these equations, such that

\begin{equation}
\bm{\tilde{R}}(\bm{q}) = \bm{U^{T}R}(\bm{q}) = \bm{P^{i}q_{i}} + \bm{Q^{ij}q_{i}q_{j}} + \bm{S^{ijk}q_{i}q_{j}q_{k}}
\label{eq_rcubicpoly}
\end{equation}

\begin{equation}
\bm{\tilde{K}}(\bm{q}) = \frac{\partial \bm{\tilde{R}}(\bm{q})}{\partial \bm{q_{l}}} = \bm{P^{l}} + (\bm{Q^{li}} + \bm{Q^{il}})\bm{q_{i}} + (\bm{S^{ijl}} + \bm{S^{ilj}} + \bm{S^{lij}} )\bm{q_{i}q_{j}}
\label{eq_rquadpoly}
\end{equation}

The reduced Euler-Lagrange equation of motion can then be solved using a Newmark integrator, animating large deformations
of deformable models more efficiently than previously possible.

This paper will start from the very beginning of the process, i.e. creating triangle objects to form a triangle mesh for any
specified model, and walk through every step until an actual animation is created at the end. OpenGL is used for drawing and displaying images, and C++ was used for the rest of the implementation.

%%%%%%%%%%%%%%%% begin figure %%%%%%%%%%%%%%%%%%%
%%% 3.34in is the maximum width you can have for a figure
\begin{figure}
\center{\includegraphics[keepaspectratio,width=4.8in, natwidth = 1570, natheight = 552]{figure/fig1.png}}
\caption{A visual representation of a third order tensor. It can be imagined in three distinct ways, depending on how you index it. Thanks to Kolda et. al for the image \cite{tensors}}
\label{fig_ex1.png}
\end{figure}
%%%%%%%%%%%%%%%% end figure %%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%% begin figure %%%%%%%%%%%%%%%%%%%
%%% 3.34in is the maximum width you can have for a figure
\begin{figure}
\center{\includegraphics[keepaspectratio,width=4.8in, natwidth = 1828, natheight = 558]{figure/fig2.png}}
\caption{A visual representation of a fourth order tensor. In code, it is treated as a vector of third order tensors.}
\label{fig_ex2.png}
\end{figure}
%%%%%%%%%%%%%%%% end figure %%%%%%%%%%%%%%%%%%%

% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{An Overview of Tensors}

Before going into the details of how to implement reduced-order St. Venant-Kirchfoff deformable models, it's important to review tensors, as they show up in many places throughout this paper. The following explanation is influenced by Kolda and Bader's paper on Tensor Decomposition and Applications \cite{tensors}, and contains extra findings that emerged through implementation.

A \textbf{tensor} is a multidimensional array. For example, a matrix is a second order tensor, and a vector is a first order tensor. An $N$th order tensor is an array of $N$ dimensions, and thus indexed using $N$ indices.

Figure~\ref{fig_ex1.png} shows a visual representation of a third order tensor; it can be imagined as a vector of matrices, where each square slice represents an individual matrix. Figure~\ref{fig_ex2.png} shows a visual representation of a fourth
order tensor, or a vector of third order tensors. Fourth order tensors are the highest dimension tensor needed for this paper, so no other tensor visuals are included.

There are three different kinds of tensor multiplication that we will use throughout this paper.

\subsection{Scalar Multiplication}

This works exactly as it seems like it would. For $a \in \mathbb{R}$, $\bm{X} \in \mathbb{R}^{I_1 \times I_2 \times ... \times I_N}$,

\begin{equation}
(a\bm{X})_{i_1, i_2, ..., i_n} = a\cdot x_{i_1, i_2, ..., i_n}
\end{equation}

%%%%%%%%%%%%%%%% begin figure %%%%%%%%%%%%%%%%%%%
%%% 3.34in is the maximum width you can have for a figure
\begin{figure}
\center{\includegraphics[keepaspectratio,width=4.8in, natwidth = 1774, natheight = 788]{figure/fig3.png}}
\caption{A visual representation of a 3-mode vector product, where $\bm{A} \in \mathbb{R}^{n \times n \times 4}$ and $\bm{f} \in \mathbb{R}^{4}$}
\label{fig_ex3.png}
\end{figure}
%%%%%%%%%%%%%%%% end figure %%%%%%%%%%%%%%%%%%%

\subsection{n-Mode Vector Product}

When a tensor is multiplied by a vector, its order reduces by 1. An n-mode vector product of a tensor $\bm{X} \in \mathbb{R}^{I_1 \times I_2 \times ... \times I_N}$ with a vector $\bm{v} \in \mathbb{R}^{I_n}$ is denoted by $\bm{X} \bar{\times}_n \bm{v}$. Elementwise,

\begin{equation}
(\bm{X} \bar{\times}_n \bm{v} )_{i_1, ..., i_{n-1}, i{n+1}, ..., i_N} = \sum_{i_n = 1}^{I_n} x_{i_1, i_2, ..., i_N}\cdot v_{i_n}
\end{equation}

So the resulting tensor $(\bm{X} \bar{\times}_n \bm{v} ) \in \mathbb{R}^{I_1 \times ... \times I_{n-1} \times I_{n+1} \times ... \times I_N}$. A visual representation of a 3-mode vector product can be seen in Figure~\ref{fig_ex3.png}.
For n-mode vector products, precedence matters, since it change which dimension of the tensor is collapsed. Therefore, if $m < n$,

\begin{equation}
\bm{X} \bar{\times}_m \bm{a} \bar{\times}_n \bm{b} = (\bm{X} \bar{\times}_m \bm{a}) \bar{\times}_{n-1} \bm{b} = (\bm{X} \bar{\times}_n \bm{b}) \bar{\times}_m \bm{a}
\label{eq_vectorMode}
\end{equation}

This is an important rule that will be used later.

\subsection{n-Mode Matrix Product}
When a tensor is multiplied by a matrix, one of its dimensions changes. An n-mode matrix product of a tensor $\bm{X} \in \mathbb{R}^{I_1 \times I_2 \times ... \times I_N}$ with a matrix $\bm{U} \in \mathbb{R}^{J \times I_n}$ is denoted by $\bm{X} \times_n \bm{U}$. Elementwise, this multiplication results in:

\begin{equation}
(\bm{X} \times_n \bm{U} )_{i_1, ..., i_{n-1}, j, i{n+1}, ..., i_N} = \sum_{i_n = 1}^{I_n} x_{i_1, i_2, ..., i_N}\cdot u_{j,i_n}
\end{equation}

and the resulting tensor $(\bm{X} \times_n \bm{U} ) \in \mathbb{R}^{I_1 \times ... \times I_{n-1} \times J \times I_{n+1} \times ... \times I_N}$.

If $n \neq m$, then

\begin{equation}
\bm{X} \times_n \bm{A} \times_m  \bm{B} = \bm{X} \times_m \bm{B} \times_n \bm{A}
\label{eq_matrixModeCommute}
\end{equation}

If the modes are the same, then

\begin{equation}
\bm{X} \times_n \bm{A} \times_n  \bm{B} = \bm{X} \times_n (\bm{BA})
\label{eq_matrixModeAssociate}
\end{equation}

These two rules will also be used later. Another important rule which will be used later is, for  a tensor $\bm{X} \in \mathbb{R}^{I_1 \times I_2 \times ... \times I_N}$, a matrix $\bm{A} \in \mathbb{R}^{I_n, J}$, and a vector $\bm{b} \in \mathbb{R}^{J}$,

\begin{equation}
\bm{X} \bar{\times}_n (\bm{Ab}) = \bm{X} \times_n \bm{A^T} \bar{\times}_n \bm{b}
\label{eq_productDecompose}
\end{equation}

% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Creating the Triangles}

When modelling solids using a discrete method, the model is represented by a mesh of polygons. In this paper, triangles were
used, so all results of this paper are based on triangle calculations.

In the code for this paper, a triangle object was created for cleaner implementation. Important variables to keep track of are:
\begin{enumerate}
  \item a vector of rest vertices. This should stay constant throughout the simulation.
  \item a vector of actual positions, which update as the whole mesh moves.
  \item a material model of some sort, to keep track of lambda and mu values for force calculations.
  \item rest area; this is used in calculating the internal force and stiffness matrix.
  \item precomputed coefficients for the cubic polynomial interpretation of internal force and quadratic polynomial
  for the tangent stiffness matrix. This will be discussed in a later section.
\end{enumerate}

In addition to storing variables, there are a few useful functions that can go into this object as well:
\begin{enumerate}
  \item getter/setter functions for all private variables.
  \item a function that computes $\frac{\partial \bm{F}}{\partial \bm{u}}$.
  \item a function that computes the deformation gradient, $\bm{F}$.
  \item a function to compute the internal force for the triangle given the deformation gradient.
  \item a function to compute the force jacobian for the triangle given the deformation gradient.
\end{enumerate}

The last three functions are not necessary for the cubic polynomial approach, but are useful for debugging purposes.
All terms used in this section will be explained in the following subsections, which will go into more details of
implementation.

% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Computing the Deformation Gradient}

When a solid is deformed, the \textbf{Deformation Gradient}, $\bm{F} \in \mathbb{R}^{2 \times 2}$, is the linear mapping from a rest vertex to its deformed position (without translation). This mapping can be used in the calculation of strain energy, so it's an important value to calculate if the cubic polynomial approach is not being used.

The deformation gradient can be found using the equation:

\begin{equation}
\bm{F} = \bm{D_sD_{m}^{-1}} = \begin{bmatrix} (x_2 - x_0) & (x_4 - x_0) \\ (x_3 - x_1) & (x_5 - x_1) \end{bmatrix} \bm{D_{m}^{-1}} = \begin{bmatrix} f_0 & f_2 \\ f_1 & f_3 \end{bmatrix}
\label{eq_F}
\end{equation}

Where $\bm{D_s}$ is the spatial matrix made of the deformed vertices, $\bm{D_m}$ is the material matrix made of the rest vertices, and the three vertices of the triangle are $(x_0, x_1), (x_2, x_3), (x_4, x_5)$. Since the rest vertices stay constant throughout the simulation, $\bm{D_{m}^{-1}}$ is constant.

% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Implementing StVK}

This section is not necessary for the cubic polynomial approach, but it's useful as a debugging tool. In the code
for this paper, the implementation of StVK is tied to the material of the triangle, and is called by the functions
that calculate internal force and the force jacobian for an individual triangle.

A St. Venant-Kirchhoff deformable model is defined by the StVK strain energy, where

\begin{equation}
\psi = \mu ||\bm{F^TF} - \bm{I}||^2 + \frac{\lambda}{2}\tr (\bm{F^TF} - \bm{I})^2
\label{eq_stvk}
\end{equation}

, and $\lambda$ and $\mu$ are Lamé coefficients.

In computing the internal force of a single triangle, the Piola-Kirchhoff stress tensor, i.e. the derivative of the strain energy by the deformation gradient, is used. The Piola-Kirchhoff stress tensor is

\begin{equation}
\frac{\partial \psi}{\partial \bm{F}} = 4\mu \bm{FF^TF} - 4\mu \bm{F} + 2\lambda \bm{F}\tr (\bm{F^TF}) -4\lambda \bm{F}
\label{eq_pk1}
\end{equation}

In computing the force jacobian of a single triangle, the energy hessian is used. The energy hessian is:

\begin{equation}
  \begin{split}
\frac{\partial^2 \psi}{\partial \bm{F}^2} = 4\mu \left[\frac{\partial \bm{F}}{\partial F_i}\bm{F^TF} + \bm{F}\frac{\partial \bm{F}}{\partial F_i}^T\bm{F} + \bm{FF^T}\frac{\partial \bm{F}}{\partial F_i}\right] \\ + 2\lambda \frac{\partial \bm{F}}{\partial F_i}\tr \left(\bm{F^TF}\right) - 4[\mu + \lambda]\bm{I}
  \end{split}
\label{eq_dpdf}
\end{equation}

% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Computing dF/dx}

Before we can calculate internal force and the force jacobian, we need to find the derivative of F in terms of x. Remember that $\bm{F} \in \mathbb{R}^{2 \times 2}$ and $\bm{x} \in \mathbb{R}^6$. This means that

\begin{equation}
  \begin{split}
    \frac{\partial \bm{F}}{\partial \bm{x}} = \begin{bmatrix} \frac{\partial \bm{F}}{\partial x_0} & \frac{\partial \bm{F}}{\partial x_1}
    & \frac{\partial \bm{F}}{\partial x_2} & \frac{\partial \bm{F}}{\partial x_3} & \frac{\partial \bm{F}}{\partial x_4}
    & \frac{\partial \bm{F}}{\partial x_5} \end{bmatrix} \\
    = \begin{bmatrix} \begin{bmatrix} -1 & -1 \\ 0 & 0 \end{bmatrix} & \begin{bmatrix} 0 & 0 \\ -1 & -1 \end{bmatrix}
  & \begin{bmatrix} 1 & 0 \\ 0 & 0 \end{bmatrix} & \begin{bmatrix} 0 & 0 \\ 1 & 0 \end{bmatrix}
  & \begin{bmatrix} 0 & 1 \\ 0 & 0 \end{bmatrix} & \begin{bmatrix} 0 & 0 \\ 0 & 1 \end{bmatrix}\end{bmatrix}
  \end{split}
\label{eq_dFdx}
\end{equation}

This was derived using equation~\ref{eq_F} for $\bm{F}$. Notice that this is a vector of matrices, i.e. a third order tensor. While we can use this as a third order tensor, it's easier to vectorize it and treat it as a matrix.

% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Flattening Matrices and Tensors}

Flattening a tensor reduces it into a matrix, and flattening a matrix reduces it into a vector (also called vectorizing). To vectorize a matrix, we append the next column onto the bottom of the previous. So, as an example, if

\bigskip
\begin{center}
$\bm{A} = \begin{bmatrix} 1 & 3 \\ 2 & 4 \end{bmatrix}$
\end{center}

then

\begin{center}
$\vect (\bm{A}) = \begin{bmatrix} 1 \\ 2 \\ 3 \\ 4 \end{bmatrix}$
\end{center}

To flatten a tensor, we do this process on each level - so if we have a fourth order tensor, or a matrix of matrices, we first flatten the outer matrix into a vector of matrices, then vectorize the matrices inside. This step, which is the same for both third and fourth order tensors, can be done as shown below:

\bigskip
\begin{center}
$\bm{A} = \begin{bmatrix} \begin{bmatrix} 1 & 3 \\ 2 & 4 \end{bmatrix} & \begin{bmatrix} 5 & 7 \\ 6 & 8 \end{bmatrix} \end{bmatrix}$
\end{center}

then

\begin{center}
$\vect (\bm{A}) = \begin{bmatrix} \vect \left(\begin{bmatrix} 1 & 3 \\ 2 & 4 \end{bmatrix}\right) & \vect \left(\begin{bmatrix} 5 & 7 \\ 6 & 8 \end{bmatrix}\right) \end{bmatrix} = \begin{bmatrix} 1 & 5 \\ 2 & 6 \\ 3 & 7 \\ 4 & 8 \end{bmatrix}$
\end{center}

% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Computing Internal Force and the Force Jacobian (The Non-Polynomial Way)}

This section is unnecessary for the cubic polynomial approach, but as with all the other sections, it's useful for debugging purposes. The internal force inside of the triangle can be computed using the equation

\begin{equation}
\bm{f} = \frac{\partial \psi}{\partial \bm{u}} = \vect \left(\frac{\partial \bm{F}}{\partial \bm{x}}\right)^T\cdot \vect \left(\frac{\partial \psi}{\partial \bm{F}}\right)
\label{eq_triforce}
\end{equation}

where the terms are defined by equations \ref{eq_dFdx} and \ref{eq_pk1}, respectively. The force jacobian for each triangle can be computed using the equation

\begin{equation}
\frac{\partial^2 \psi}{\partial \bm{u}^2} = \vect \left(\frac{\partial \bm{F}}{\partial \bm{x}}\right)^T\cdot \frac{\partial^2 \psi}{\partial \bm{F}^2}\cdot \vect \left(\frac{\partial \bm{F}}{\partial \bm{x}}\right)
\label{eq_trijacob}
\end{equation}

where the terms are defined by equations \ref{eq_dFdx} and \ref{eq_dpdf}. Notice how $\bm{x}$, or current vertex placement, and $\bm{u}$, vertex \textit{displacement}, are used interchangably here. In general, this is possible because the interal force at rest position $\bm{\bar{x}}$ is $0$, and $\bm{x} = \bm{\bar{x}} + \bm{u}$. However, it is important to note, because these will \textbf{not} be interchangable in the cubic polynomial approach.

% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Creating the Triangle Mesh}

Now that a triangle object has been established, a triangle mesh can be built. In the code for this paper, the triangle mesh is a separate object from the individual triangles, and it stores all of the triangles in a vector. When constructing the triangle mesh, it may be useful to store a map of each vertex to its global position, so that future calculations are easier. In this implementation, the following were stored as private variables:

\begin{enumerate}
  \item a vector of triangles, i.e. the triangle mesh.
  \item a vertex to global index mapping.
  \item a vector of vertex placements.
  \item a vector of vertex rest positions.
  \item a vector of vertex displacements.
  \item a vector of vertex indices representing which vertices are \textbf{constrained}.
  \item a vector of vertex indices representing which vertices are \textbf{unconstrained}.
  \item a vector for inteneral force.
  \item a vector for external force.
  \item a mass matrix.
  \item a vector for velocity and a vector for acceleration.
  \item the basis reduction matrix.
  \item a vector for the reduced basis vector.
\end{enumerate}

% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Implementing the Euler-Lagrange Equation of Motion}

After setting up the triangle mesh and applying some kind of external force,the system is animated by solving the Euler-Lagrange Equation of Motion. By solving equation~\ref{eq_motion}, the displacements for the next time step can be found and added to the vertex placements. In order to do this, each term of the equation must be calculated.

% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Implementing Internal Force}

While this step isn't necessary for the cubic polynomial approach, the methods are similar. In the previous section, the individual internal force for each triangle was calculated using equation~\ref{eq_triforce}. To calculate the global internal force, $\bm{R}(\bm{u}) \in \mathbb{R}^{2n}$, all of the individual internal forces are added up. This can be done by looping through every triangle, then looping through every vertex of the triangle. For each vertex, find where it belongs in the global context, and, if it is not constrained, add the force to the global vector. Here's an example through pseudocode below:

\begin{algorithmic}[1]
    \Function{globalInternalForce}{$null$}
        \State $global\_vector.setZero()$
        \For{triangle in triangles}
         \State $force \gets triangle.force()$
          \For{vertex in triangle vertices}
              \If {vertex is unconstrained}
                  \State $i \gets global\_index(vertex)$
                  \State add to global vector
              \EndIf
            \EndFor
        \EndFor
    \EndFunction
\end{algorithmic}

% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Implementing the Tangent Stiffness Matrix}

The process here is similar to the process of calculating the global internal force. In the previous section, the individual force jacobian for each triangle was calculated using equation~\ref{eq_trijacob}. To calculate the global stiffness matrix, $\bm{K}(\bm{u}) \in \mathbb{R}^{2n \times 2n}$, all of the individual force jacobians are added up. This can be done by looping through every triangle, then looping through every vertex of the triangle twice. For each vertex, find where it belongs in the global context, and, if it is not constrained, add the force to the global stiffness matrix. Here's an example through pseudocode below:

\begin{algorithmic}[1]
    \Function{globalStiffnessMatrix}{$null$}
        \State $global\_stiffness.setZero()$
        \For{triangle in triangles}
         \State $jacobian \gets triangle.jacobian()$
          \For{$vertex$ in triangle vertices}
              \If {$vertex$ is unconstrained}
                  \State $i \gets global\_index(vertex)$
                  \For{$vertex_2$ in triangle vertices}
                      \If {$vertex_2$ is unconstrained}
                          \State $j \gets global\_index(vertex_2)$
                          \State add to global stiffness matrix
                      \EndIf
                    \EndFor
              \EndIf
            \EndFor
        \EndFor
    \EndFunction
\end{algorithmic}

% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Implementing the Mass Matrix}

The mass matrix does not change over time, so this can be initialized outside of the motion function. How mass is implemented is up to the creator.

% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Implementing the Damping Matrix}

The damping matrix is calculated using the equation

\begin{equation}
\bm{D}(\bm{u}) = \left(\alpha \bm{M} - \beta \bm{K}(\bm{u})\right)
\label{eq_damp}
\end{equation}

After computing the global stiffness matrix, this should be straightforward. The alpha and beta values are constant values that are up to the creator, depending on how strong the desired force is.

% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Implementing the Newmark Integrator}

After calculating all of the individual terms in the Euler-Lagrange equation of motion, the equation can be solved for a given timestep using an implicit Newmark integrator. Implicit Newmark integrators are second-order accurate, and they only require one step, instead of having to solve the equation in a few iterations. While the pseudocode below is written for unreduced displacements, this iteration stays exactly the same when $u$ is replaced with $q$.

\begin{algorithmic}[1]
    \Function{NewmarkIntegrator}{$null$}
      \State $\bm{u_{i + 1}} \gets \bm{u_i}$
      \State Evaluate internal forces $\bm{R}(\bm{u_i})$
      \State Evaluate the stiffness matrix $\bm{K}(\bm{u_i})$
      \State Calculate the damping matrix, $\bm{D}(\bm{u_i}) = \alpha \bm{M} - \beta \bm{K}$
      \State Calculate the system matrix, $\bm{A} = \alpha_1\bm{M} + \alpha_4\bm{D}(\bm{u_i}) - \bm{K}$
      \State residual $\gets (\alpha_3\bm{M} - \alpha_6\bm{D}) \bm{ \ddot u_i} + (\alpha_2\bm{M} - \alpha_5\bm{D}) \bm{ \dot u_{i}} + \bm{R}(\bm{u_i}) + \bm{f_{i+1}}$
      \State $ \Delta \bm{u} \gets \bm{A^{-1}} \cdot $ residual
      \State $ \bm{u_{i + 1}} \gets \bm{u_{i + 1}} + \Delta \bm{u}$
      \State $ \bm{ \dot u_{i + 1}} \gets \alpha_4(\bm{u_{i+1}} - \bm{u_i}) + \alpha_5 \bm{ \dot u_i} + \alpha_6 \bm{ \ddot u_i}$
      \State $ \bm{ \ddot u_{i + 1}} \gets \alpha_1(\bm{u_{i+1}} - \bm{u_i}) - \alpha_2 \bm{\dot u_i} - \alpha_3 \bm{\ddot u_i}$
    \EndFunction
\end{algorithmic}

The alpha constants in this integrator are determined by the equations

\begin{center}
$\alpha_1 = \frac{1}{\tilde{\beta}(\Delta t)^2}, \alpha_2 = \frac{1}{\tilde{\beta}\Delta t},
\alpha_3 = \frac{1 - 2\tilde{\beta}}{2\tilde{\beta}}, \alpha_4 = \frac{\tilde{\gamma}}{\tilde{\beta}\Delta t},$

$\alpha_5 = 1 - \frac{\tilde{\gamma}}{\tilde{\beta}}, \alpha_6 = \left(1 - \frac{\tilde{\gamma}}{2\tilde{\beta}}\right)\Delta t$
\end{center}

Where $0 \leq \tilde{\beta} \leq 0.5$ and $0 \leq \tilde{\gamma} \leq 1$. We chose $\tilde{\beta} = 0.25$ and $\tilde{\gamma} = 0.5$ for this implementation, but Barbič and James chose $\tilde{\beta} = 0$ and $\tilde{\gamma} = 0.5$.

% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Generating Precomputed Coefficients}

At this point in the paper, a fully function simulator of St. Venant-Kirchhoff deformable models can be created; however, they are still unreduced and lack any precomputation. If precomputation does not interest you, feel free to skip to the section titled \textbf{Generating a Deformation Basis} - after creating a deformation basis, reducing everything is as simple as following equations \ref{eq_basisreduction} - \ref{eq_rstiffness}.

For simplicity, we derived the precomputed constant coefficients before reducing the equation. In order to have the ability to precompute constant coefficients, all variables must be extractable. In the case of unreduced St. Venant Kirchhoff models, this means that we should be able to separate vertex positions, $x$, out of the internal force and stiffness matrix calculation. Again, for simplicity, we began by separating $x$ from the internal force equation \ref{eq_triforce} and force jacobian equation \ref{eq_trijacob} for an individual triangle, then created global constants similar to how the global internal force and global stiffness matrix were built in sections 5.1 and 5.2.

% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Coefficients for the Tangent Stiffness Matrix}

Looking at equation~\ref{eq_dpdf}, there is clearly one quadratic term, and one constant matrix, $-4[\mu + \lambda]I$. From this, we can already derive the constant coefficient term:

\begin{equation}
  \bm{Q} = - \vect \left(\frac{\partial \bm{F}}{\partial \bm{x}}\right)^T 4[\mu + \lambda]\bm{I} \vect \left(\frac{\partial \bm{F}}{\partial \bm{x}}\right)
  \label{eq_unreducedConst}
\end{equation}

The quadratic term is trickier. Looking at the $\mu$ term of $\frac{\partial^2 \psi}{\partial \bm{F}^2}$ alone, $\left[\frac{\partial \bm{F}}{\partial F_i}\bm{F^TF} + \bm{F}\frac{\partial \bm{F}}{\partial F_i}^T\bm{F} + \bm{FF^T}\frac{\partial \bm{F}}{\partial F_i}\right]$ decomposes into

\begin{center}
$\frac{\partial \bm{F}}{\partial F_i}\bm{F^TF} = \begin{bmatrix} f_{0}^2 + f_{1}^2 & 0 & f_0f_2 + f_1f_3 & 0 \\
0 & f_{0}^2 + f_{1}^2 & 0 & f_0f_2 + f_1f_3 \\
f_0f_2 + f_1f_3 & 0 & f_{2}^2 + f_{3}^2 & 0 \\
0 & f_0f_2 + f_1f_3 & 0 & f_{2}^2 + f_{3}^2 \end{bmatrix}$

\bigskip
$\bm{F}\frac{\partial \bm{F}}{\partial F_i}^T\bm{F} = \begin{bmatrix} f_{0}^2 & f_0f_1 & f_0f_2 & f_1f_2  \\
f_0f_1 & f_{1}^2 & f_0f_3 & f_1f_3 \\
f_0f_2 & f_0f_3 & f_{2}^2 & f_2f_3 \\
f_1f_2 & f_1f_3 & f_2f_3 & f_{3}^2 \end{bmatrix}$

\bigskip
$\bm{FF^T}\frac{\partial \bm{F}}{\partial F_i} = \begin{bmatrix} f_{0}^2 + f_{2}^2 & f_0f_1 + f_2f_3 & 0 & 0  \\
f_0f_1 + f_2f_3 & f_{1}^2 + f_{3}^2 & 0 & 0 \\
0 & 0 & f_{0}^2 + f_{2}^2 & f_0f_1 + f_2f_3 \\
0 & 0 & f_0f_1 + f_2f_3 & f_{1}^2 + f_{3}^2 \end{bmatrix}$
\end{center}

In order to separate out all of the $\bm{x}$'s, we can first separate all of the $\bm{f}$ terms. It turns out that this can be done using tensors. By working backwards from the matrices above, a fourth order tensor, $\bm{C_{\mu}}$, can be derived, such that

\begin{equation}
    \bm{C_{\mu}} = \begin{bmatrix}
    \begin{bmatrix} 3 & 0 & 0 & 0 \\ 0 & 1 & 0 & 0 \\ 0 & 0 & 1 & 0 \\ 0 & 0 & 0 & 0 \end{bmatrix} &
    \begin{bmatrix} 0 & 2 & 0 & 0 \\ 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 1 \\ 0 & 0 & 0 & 0 \end{bmatrix} &
    \begin{bmatrix} 0 & 0 & 2 & 0 \\ 0 & 0 & 0 & 1 \\ 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 \end{bmatrix} &
    \begin{bmatrix}0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 \\ 0 & 1 & 0 & 0 \\ 0 & 0 & 0 & 0 \end{bmatrix} \\
      \begin{bmatrix} 0 & 0 & 0 & 0 \\ 2 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 \\ 0 & 0 & 1 & 0 \end{bmatrix} &
      \begin{bmatrix} 1 & 0 & 0 & 0 \\ 0 & 3 & 0 & 0 \\ 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 1 \end{bmatrix} &
      \begin{bmatrix} 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 \\ 1 & 0 & 0 & 0 \end{bmatrix} &
      \begin{bmatrix}0 & 0 & 1 & 0 \\ 0 & 0 & 0 & 2 \\ 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 \end{bmatrix} \\
        \begin{bmatrix} 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 \\ 2 & 0 & 0 & 0 \\ 0 & 1 & 0 & 0 \end{bmatrix} &
        \begin{bmatrix} 0 & 0 & 0 & 1 \\ 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 \end{bmatrix} &
        \begin{bmatrix} 1 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 \\ 0 & 0 & 3 & 0 \\ 0 & 0 & 0 & 1 \end{bmatrix} &
        \begin{bmatrix}0 & 1 & 0 & 0 \\ 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 2 \\ 0 & 0 & 0 & 0 \end{bmatrix} \\
          \begin{bmatrix} 0 & 0 & 0 & 0 \\ 0 & 0 & 1 & 0 \\ 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 \end{bmatrix} &
          \begin{bmatrix} 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 \\ 1 & 0 & 0 & 0 \\ 0 & 2 & 0 & 0 \end{bmatrix} &
          \begin{bmatrix} 0 & 0 & 0 & 0 \\ 1 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 \\ 0 & 0 & 2 & 0 \end{bmatrix} &
          \begin{bmatrix}0 & 0 & 0 & 0 \\ 0 & 1 & 0 & 0 \\ 0 & 0 & 1 & 0 \\ 0 & 0 & 0 & 3 \end{bmatrix} \end{bmatrix}
\label{_eq_quadmu}
\end{equation}

And
\begin{equation}
\begin{split}
4\mu\left[\frac{\partial \bm{F}}{\partial F_i}\bm{F^TF} + \bm{F}\frac{\partial \bm{F}}{\partial F_i}^T\bm{F} + \bm{FF^T}\frac{\partial \bm{F}}{\partial F_i}\right] =
\\ 4\mu \bm{C_{\mu}} \bar{\times}_4 \vect (\bm{F}) \bar{\times}_3 \vect (\bm{F})
\end{split}
\end{equation}

Similar to the $\mu$ term, the $\lambda$ term, which can be split into the two terms:

\begin{center}
  $2\lambda \left(\frac{\partial \bm{F}}{\partial F_i}\tr \left(\bm{F^TF}\right) \right)  = 2\lambda \left(f_{0}^2 + f_{1}^2 + f_{2}^2  + f_{3}^2\right) \begin{bmatrix}
  1 & 0 & 0 & 0  \\
  0 & 1  & 0 & 0 \\
  0 & 0 & 1  & 0 \\
  0 & 0 & 0 & 1  \end{bmatrix}$

  \bigskip
  $2\lambda \left(\bm{F}\frac{\partial \tr \left(\bm{F^TF}\right)}{\partial F_i}\right)  = 2\lambda \begin{bmatrix}
  2f_{0}^2 & 2f_0f_1 & 2f_0f_2 & 2f_0f_3  \\
  2f_0f_1 & 2f_{1}^2 & 2f_1f_2 & 2f_1f_3 \\
  2f_0f_2 & 2f_1f_2 & 2f_{2}^2 & 2f_2f_3 \\
  2f_0f_3 & 2f_1f_3 & 2f_2f_3 & 2f_{3}^2  \end{bmatrix}$
\end{center}

has a fourth order tensors that can be derived:

\begin{equation}
    \bm{C_{\lambda}} = \begin{bmatrix}
    \begin{bmatrix} 3 & 0 & 0 & 0 \\ 0 & 1 & 0 & 0 \\ 0 & 0 & 1 & 0 \\ 0 & 0 & 0 & 1 \end{bmatrix} &
    \begin{bmatrix} 0 & 2 & 0 & 0 \\ 2 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 \end{bmatrix} &
    \begin{bmatrix} 0 & 0 & 2 & 0 \\ 0 & 0 & 0 & 0 \\ 2 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 \end{bmatrix} &
    \begin{bmatrix}0 & 0 & 0 & 2 \\ 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 \\ 2 & 0 & 0 & 0 \end{bmatrix} \\
      \begin{bmatrix} 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 \end{bmatrix} &
      \begin{bmatrix} 1 & 0 & 0 & 0 \\ 0 & 3 & 0 & 0 \\ 0 & 0 & 1 & 0 \\ 0 & 0 & 0 & 1 \end{bmatrix} &
      \begin{bmatrix} 0 & 0 & 0 & 0 \\ 0 & 0 & 2 & 0 \\ 0 & 2 & 0 & 0 \\ 0 & 0 & 0 & 0 \end{bmatrix} &
      \begin{bmatrix}0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 2 \\ 0 & 0 & 0 & 0 \\ 0 & 2 & 0 & 0 \end{bmatrix} \\
        \begin{bmatrix} 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 \end{bmatrix} &
        \begin{bmatrix} 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 \end{bmatrix} &
        \begin{bmatrix} 1 & 0 & 0 & 0 \\ 0 & 1 & 0 & 0 \\ 0 & 0 & 3 & 0 \\ 0 & 0 & 0 & 1 \end{bmatrix} &
        \begin{bmatrix}0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 2 \\ 0 & 0 & 2 & 0 \end{bmatrix} \\
          \begin{bmatrix} 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 \end{bmatrix} &
          \begin{bmatrix} 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 \end{bmatrix} &
          \begin{bmatrix} 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 \end{bmatrix} &
          \begin{bmatrix}1 & 0 & 0 & 0 \\ 0 & 1 & 0 & 0 \\ 0 & 0 & 1 & 0 \\ 0 & 0 & 0 & 3 \end{bmatrix} \end{bmatrix}
\label{_eq_quadlambda}
\end{equation}

And
\begin{equation}
2\lambda \left[\frac{\partial \bm{F}}{\partial F_i}\tr \left(\bm{F^TF}\right) + \bm{F}\frac{\partial \tr \left(\bm{F^TF}\right)}{\partial F_i} \right] = 2\lambda \bm{C_{\lambda}} \bar{\times}_4 \vect (\bm{F}) \bar{\times}_3 \vect (\bm{F})
\end{equation}

So the entire quadratic term of equation~\ref{eq_dpdf} can be written as

\begin{multline}
\bm{C_f} \bar{\times}_4 \vect (\bm{F}) \bar{\times}_3 \vect (\bm{F}) =  \\ \left(4\mu \bm{C_{\mu}} + 2\lambda \bm{C_{\lambda}}\right) \bar{\times}_4 \vect (\bm{F}) \bar{\times}_3 \vect (\bm{F})
\end{multline}

This still only separates $\bm{F}$, not $\bm{x}$. However, since $\bm{F} = \frac{\partial \bm{F}}{\partial \bm{x}}\bm{x}$, we can rearrange this equation using our tensor product rules (equations~\ref{eq_vectorMode}-\ref{eq_productDecompose}) so that
\begin{center}
  \begin{multline}
  \bm{C_f} \bar{\times}_4 \vect (\bm{F}) \bar{\times}_3 \vect (\bm{F}) = \bm{C_f} \bar{\times}_4 \vect \left( \frac{\partial \bm{F}}{\partial \bm{x}}\bm{x}\right) \bar{\times}_3 \vect \left( \frac{\partial \bm{F}}{\partial \bm{x}}\bm{x}\right)
  \\ = \bm{C_f} \bar{\times}_4 \vect \left( \frac{\partial \bm{F}}{\partial \bm{x}}\right) \vect (\bm{x}) \bar{\times}_3 \vect \left( \frac{\partial \bm{F}}{\partial \bm{x}}\right) \vect (\bm{x})
  \\ = \bm{C_f} \times_4 \vect \left( \frac{\partial \bm{F}}{\partial \bm{x}}\right)^T \bar{\times}_4 \vect (\bm{x}) \times_3 \vect \left( \frac{\partial \bm{F}}{\partial \bm{x}}\right)^T \bar{\times}_3 \vect (\bm{x})
  \\ = \left[\bm{C_f} \times_4 \vect \left( \frac{\partial \bm{F}}{\partial \bm{x}}\right)^T \times_3 \vect \left( \frac{\partial \bm{F}}{\partial \bm{x}}\right)^T\right] \bar{\times}_4 \vect (\bm{x}) \bar{\times}_3 \vect (\bm{x})
\end{multline}
\end{center}

Since $\frac{\partial \bm{F}}{\partial \bm{x}}$ is constant (refer back to equation~\ref{eq_dFdx}), this can be pushed into our constant, so that our equation~\ref{eq_dpdf} quadratic constant can be written as

\begin{equation}
\bm{C_{dpdf}}  = \bm{C_f} \times_4 \vect \left( \frac{\partial \bm{F}}{\partial \bm{x}} \right)^T \times_3 \vect \left( \frac{\partial \bm{F}}{\partial \bm{x}}\right)^T
\end{equation}

This constant is still for equation~\ref{eq_dpdf}, not the force jacobian. The only step left in calculating the triangle force jacobian's quadratic coefficient is to multiply it on both sides by $\left(\frac{\partial \bm{F}}{\partial \bm{x}}\right)$:

\begin{multline}
\bm{C}  = \vect \left( \frac{\partial \bm{F}}{\partial \bm{x}} \right)^T \bm{C_{dpdf}} \vect \left( \frac{\partial \bm{F}}{\partial \bm{x}} \right)
\\ = \bm{C_{dpdf}} \times_2 \vect \left( \frac{\partial \bm{F}}{\partial \bm{x}} \right)^T \times_1 \vect \left( \frac{\partial \bm{F}}{\partial \bm{x}}\right)^T
\end{multline}

% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Creating the Global Tangent Stiffness Matrix Coefficients}

Now that the constant terms for the force jacobian for each triangle has been computed, we can create global constant terms for the tangent stiffness matrix in a similar manner as how the global tangent stiffness matrix was computed earlier.

\begin{algorithmic}[1]
    \Function{globalStiffnessConstants}{$null$}
        \State $Q_{global}.setZero()$
        \State $C_{global}.setZero()$
        \For{triangle in triangles}
         \State $Q \gets triangle.getQ()$
         \State $C \gets triangle.getC()$
          \For{$vertex$ in triangle vertices}
              \If {$vertex$ is unconstrained}
                  \State $i \gets global\_index(vertex)$
                  \For{$vertex_2$ in triangle vertices}
                      \If {$vertex_2$ is unconstrained}
                          \State $j \gets global\_index(vertex_2)$
                          \State $Q_{global}(i,j) \gets Q_{global}(i,j) + Q(vertex, vertex_2)$
                          \For{$vertex_3$ in triangle vertices}
                                \State $k \gets global\_index(vertex_3)$
                                \For{$vertex_4$ in triangle vertices}
                                    \State $l \gets global\_index(vertex_4)$
                                    \State $C_{global}(i,j,k,l)  \gets C_{global}(i,j,k,l)+C(vertex, vertex_2, vertex_3, vertex_4)$
                                  \EndFor
                            \EndFor
                      \EndIf
                    \EndFor
              \EndIf
            \EndFor
        \EndFor
    \EndFunction
\end{algorithmic}

Note that the global coefficients match the order of the triangle coefficients; that is, the constant term, $\bm{Q_{global}}$ is a matrix, while the global coefficient for the quadratic term, $\bm{C_{global}}$, is a fourth-order tensor. The difference is in their dimensions; while $\bm{Q} \in \mathbb{R}^{6 \times 6}$, $\bm{Q_{global}} \in \mathbb{R}^{2n \times 2n}$, and while  $\bm{C} \in \mathbb{R}^{6 \times 6 \times 6 \times 6}$, $\bm{C_{global}} \in \mathbb{R}^{2n \times 2n \times 2n \times 2n}$.

Also note that this pseudocode is abbreviated; while it only shows adding $\bm{C}$ and $\bm{Q}$ to one position in the global coefficients, you actually have to add it to every possible combination of the current vertices's $x$ and $y$ coordinates. For example, if $vertex$ and $vertex_2$ are unconstrained, then

\begin{center}
$\bm{Q_{global}}(i,j) += \bm{Q}(vertex(x), vertex_2(x))$,

$\bm{Q_{global}}(i + 1,j) += \bm{Q}(vertex(y), vertex_2(x))$,

$\bm{Q_{global}}(i ,j + 1) += \bm{Q}(vertex(x), vertex_2(y))$, and

$\bm{Q_{global}}(i + 1,j + 1) += \bm{Q}(vertex(y), vertex_2(y))$.
\end{center}

% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Coefficients for Internal Force}

Looking at equation~\ref{eq_pk1}, there is clearly one cubic term and one linear term. Since the force jacobian is the derivative of internal force, the linear coefficient for internal force is actually also $\bm{Q}$ (eq \ref{eq_unreducedConst}). The connection between the cubic term and the quadratic term, however, is not as clean, because the cubic term can be reduced into a fourth order tensor as well. We are able to reduce the coefficient for the cubic term into a fourth order tensor because equation~\ref{eq_pk1} is vectorized, reducing its order by one.

The vectorized cubic term, before separating $\bm{x}$, is

\begin{center}
  $\vect \left( 4\mu\bm{FF^TF} + 2\lambda\tr\left(\bm{F^TF}\right)\bm{F}\right)$
\end{center}

where

\begin{center}
  $\vect \left( 4\mu\bm{FF^TF} \right) = 4\mu
  \begin{bmatrix}
    f_{0}^3 + f_0f_{1}^2 + f_0f_{2}^2 + f_1f_2f_3 \\
    f_{0}^2f_{1} + f_{1}^3 + f_0f_2f_3 + f_1f_{3}^2 \\
    f_{0}^2f_{2} + f_0f_1f_3 + f_{2}^3 + f_2f_{3}^2 \\
    f_0f_1f_2 + f_{1}^2f_3 + f_{2}^2f_3 + f_{3}^3 \\
    \end{bmatrix}$

    \bigskip
    $\vect \left( 2\lambda\tr\left(\bm{F^TF}\right)\bm{F} \right) = 2\lambda
    \begin{bmatrix}
      f_{0}^3 + f_0f_{1}^2 + f_0f_{2}^2 + f_0f_{3}^2 \\
      f_{0}^2f_1 + f_{1}^3 + f_1f_{2}^2 + f_1f_{3}^2 \\
      f_{0}^2f_2 + f_2f_{1}^2 + f_{2}^3 + f_2f_{3}^2 \\
      f_{0}^2f_3 + f_3f_{1}^2 + f_3f_{2}^2 + f_{3}^3\\
      \end{bmatrix}$
\end{center}

In order to separate out all of the $\bm{x}$'s, we can first separate all of the $\bm{f}$ terms, like we did for the force jacobian. By working backwards from the matrices above, two fourth order tensor, $\bm{A_{\mu}}$ and $\bm{A_{\lambda}}$, can be derived, such that

\begin{equation}
    \bm{A_{\mu}} = \begin{bmatrix}
    \begin{bmatrix} 1 & 0 & 0 & 0 \\ 0 & 1 & 0 & 0 \\ 0 & 0 & 1 & 0 \\ 0 & 0 & 0 & 0 \end{bmatrix} &
    \begin{bmatrix} 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 1 \\ 0 & 0 & 0 & 0 \end{bmatrix} &
    \begin{bmatrix} 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 \end{bmatrix} &
    \begin{bmatrix} 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 \end{bmatrix} \\
      \begin{bmatrix} 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 \\ 0 & 0 & 1 & 0 \end{bmatrix} &
      \begin{bmatrix} 1 & 0 & 0 & 0 \\ 0 & 1 & 0 & 0 \\ 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 1 \end{bmatrix} &
      \begin{bmatrix} 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 \end{bmatrix} &
      \begin{bmatrix} 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 \end{bmatrix} \\
        \begin{bmatrix} 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 \end{bmatrix} &
        \begin{bmatrix} 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 \end{bmatrix} &
        \begin{bmatrix} 1 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 \\ 0 & 0 & 1 & 0 \\ 0 & 0 & 0 & 1 \end{bmatrix} &
        \begin{bmatrix} 0 & 1 & 0 & 0 \\ 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 \end{bmatrix} \\
          \begin{bmatrix} 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 \end{bmatrix} &
          \begin{bmatrix} 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 \end{bmatrix} &
          \begin{bmatrix} 0 & 0 & 0 & 0 \\ 1 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 \end{bmatrix} &
          \begin{bmatrix} 0 & 0 & 0 & 0 \\ 0 & 1 & 0 & 0 \\ 0 & 0 & 1 & 0 \\ 0 & 0 & 0 & 1 \end{bmatrix} \\ \end{bmatrix}
\label{eq_cubmu}
\end{equation}

and

\begin{equation}
    \bm{A_{\lambda}} = \begin{bmatrix}
    \begin{bmatrix} 1 & 0 & 0 & 0 \\ 0 & 1 & 0 & 0 \\ 0 & 0 & 1 & 0 \\ 0 & 0 & 0 & 1 \end{bmatrix} &
    \begin{bmatrix} 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 \end{bmatrix} &
    \begin{bmatrix} 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 \end{bmatrix} &
    \begin{bmatrix} 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 \end{bmatrix} \\
      \begin{bmatrix} 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 \end{bmatrix} &
      \begin{bmatrix} 1 & 0 & 0 & 0 \\ 0 & 1 & 0 & 0 \\ 0 & 0 & 1 & 0 \\ 0 & 0 & 0 & 1 \end{bmatrix} &
      \begin{bmatrix} 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 \end{bmatrix} &
      \begin{bmatrix} 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 \end{bmatrix} \\
        \begin{bmatrix} 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 \end{bmatrix} &
        \begin{bmatrix} 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 \end{bmatrix} &
        \begin{bmatrix} 1 & 0 & 0 & 0 \\ 0 & 1 & 0 & 0 \\ 0 & 0 & 1 & 0 \\ 0 & 0 & 0 & 1 \end{bmatrix} &
        \begin{bmatrix} 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 \end{bmatrix} \\
          \begin{bmatrix} 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 \end{bmatrix} &
          \begin{bmatrix} 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 \end{bmatrix} &
          \begin{bmatrix} 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 \end{bmatrix} &
          \begin{bmatrix} 1 & 0 & 0 & 0 \\ 0 & 1 & 0 & 0 \\ 0 & 0 & 1 & 0 \\ 0 & 0 & 0 & 1 \end{bmatrix} \\ \end{bmatrix}
\label{eq_cublambda}
\end{equation}

such that

\begin{multline}
    \bm{A_f} \bar{\times}_4 \vect \bm{F} \bar{\times}_3 \vect \bm{F}  \bar{\times}_2 \vect \bm{F}
    \\ = \left( 4\mu\bm{A_{\mu}} + 2\lambda\bm{A_{\lambda}}\right) \bar{\times}_4 \vect \bm{F} \bar{\times}_3 \vect \bm{F} \bar{\times}_2 \vect \bm{F}
    \\ = \vect \left( 4\mu\bm{FF^TF} + 2\lambda\tr\left(\bm{F^TF}\right)\bm{F}\right)
\end{multline}

Then, by replacing $\bm{F} = \left( \frac{\partial \bm{F}}{\partial \bm{x}} \bm{x}\right)$ and pushing $\frac{\partial \bm{F}}{\partial \bm{x}}$ to the left side of the equation, we end up with a fourth order tensor, $\bm{A_{pk}}$, such that

\begin{equation}
\bm{A_{pk}} = \bm{A_f} \times_4 \vect \left(\frac{\partial \bm{F}}{\partial \bm{x}} \right)
\times_3 \vect \left(\frac{\partial \bm{F}}{\partial \bm{x}} \right)
\times_2 \vect \left(\frac{\partial \bm{F}}{\partial \bm{x}} \right)
\end{equation}

$\bm{A_{pk}}$ is the coefficient for the cubic term in the PK1 equation (\ref{eq_pk1}). To make this a coefficient for internal force, it must be multiplied once more by $\vect \left(\frac{\partial \bm{F}}{\partial \bm{x}} \right)$ (eq. \ref{eq_triforce}):

\begin{equation}
\bm{A} = \bm{A_{pk}} \times_1 \vect \left(\frac{\partial \bm{F}}{\partial \bm{x}} \right)
\label{eq_cubicTerm}
\end{equation}

% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Creating the Global Internal Force Coefficients}

Now that the coefficients for the internal force for each triangle has been computed, we can create global constant coefficients for internal force in a similar manner as how the global internal force was computed earlier.

\begin{algorithmic}[1]
    \Function{globalForceConstants}{$null$}
        \State $P_{global}.setZero()$
        \State $A_{global}.setZero()$
        \For{triangle in triangles}
         \State $P \gets triangle.getQ()$
         \State $A \gets triangle.getC()$
          \For{$vertex$ in triangle vertices}
              \If {$vertex$ is unconstrained}
                  \State $i \gets global\_index(vertex)$
                  \For{$vertex_2$ in triangle vertices}
                    \State $j \gets global\_index(vertex_2)$
                    \State $P_{global}(i,j) \gets P_{global}(i,j) + P(vertex, vertex_2)$
                    \For{$vertex_3$ in triangle vertices}
                          \State $k \gets global\_index(vertex_3)$
                          \For{$vertex_4$ in triangle vertices}
                              \State $l \gets global\_index(vertex_4)$
                              \State $A_{global}(i,j,k,l)  \gets A_{global}(i,j,k,l)+A(vertex, vertex_2, vertex_3, vertex_4)$
                            \EndFor
                      \EndFor
                    \EndFor
              \EndIf
            \EndFor
        \EndFor
    \EndFunction
\end{algorithmic}

Like the pseudocode for computing the global stiffness matrix coefficients, the assignment lines are abbreviated in the same way. Refer back to \textbf{Creating the Global Tangent Stiffness Matrix Coefficients} for a refresher.

Also note how a separate global matrix, $\bm{P_{global}}$, was created here, despite the fact the linear internal force coefficient is identitical to the constant force jacobian coefficient for a single triangle. This is because the loops they run through are slightly different - in the pseudocode above, $\bm{Q}$ is added to $\bm{P_{global}}$ so long as the first vertex is unconstrained. In the pseudocode for the stiffness matrix, $\bm{Q}$ is added to $\bm{Q_{global}}$ only if the first \textbf{and} the second vertex are unconstrained. $\bm{P_{global}} \neq \bm{Q_{global}}$!

% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Generating a Deformation Basis}

An explanation of how to generate a deformation basis.

% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Reducing the Euler-Lagrange Equation of Motion}

Now that a deformation basis has been generated, it can be used to reduce the order of the Euler-Lagrange equation of motion calculation. The next three subsections explain how these reductions can be done.  

% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Reducing the Internal Force}

An explanation of how to reduce the calculation of the internal forces, changing the coefficients
of the polynomial.

% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Reducing the Global Tangent Stiffness Matrix}

An explanation of how to reduce the calculation of the stiffness, changing the coefficients
of the polynomial.

% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Reducing All Other Forces}

For reducing external force and mass, follow equations \ref{eq_rmass}, \ref{eq_rexternal}. The reduced damping matrix can be calculated after mass and stiffness are reduced, so that

\begin{equation}
  \bm{\tilde{D}} = \alpha\bm{\tilde{M}} - \beta\bm{\tilde{K}}(\bm{q})
\end{equation}

After everything is reduced, run the Newmark integrator exactly as before. Refer back to the section titled \textbf{Implementing the Newmark Integrator} for a reminder of how to implement it.

% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Conclusions}

End it by explaining how we hope this helps anyone who wants to try implementing this on their own.
Explain how this can probably be optimized further by flattening all tensors.

% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{acknowledgment}

Thanks to Barbič et. al for writing the paper and my advisor Theodore Kim.

\end{acknowledgment}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Here's where you specify the bibliography style file.
% The full file name for the bibliography style file
% used for an ASME paper is asmems4.bst.
\bibliographystyle{asmems4}

% Here's where you specify the bibliography database file.
% The full file name of the bibliography database for this
% article is asme2e.bib. The name for your database is up
% to you.
\bibliography{writeup}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \appendix       %%% starting appendix
% \section*{Appendix A: Head of First Appendix}
% \begin{center}
%   $2\lambda (\frac{\partial F}{\partial F_i}tr(F^TF)  = 2\lambda(f_{0}^2 + f_{1}^2 + f_{2}^2  + f_{3}^2) \begin{bmatrix}
%   1 & 0 & 0 & 0  \\
%   0 & 1  & 0 & 0 \\
%   0 & 0 & 1  & 0 \\
%   0 & 0 & 0 & 1  \end{bmatrix}$
%
%   \bigskip
%   $2\lambda (F\frac{\partial tr(F^TF)}{\partial F_i})  = 2\lambda \begin{bmatrix}
%   2f_{0}^2 & 2f_0f_1 & 2f_0f_2 & 2f_0f_3  \\
%   2f_0f_1 & 2f_{1}^2 & 2f_1f_2 & 2f_1f_3 \\
%   2f_0f_2 & 2f_1f_2 & 2f_{2}^2 & 2f_2f_3 \\
%   2f_0f_3 & 2f_1f_3 & 2f_2f_3 & 2f_{3}^2  \end{bmatrix}$
% \end{center}

\end{document}
